import 'dart:convert';
import 'dart:io';
import 'package:shared_preferences/shared_preferences.dart';
import '../core/http_client.dart';
import '../core/constants.dart';
import '../models/user.dart';
import '../services/user_service.dart';
import '../utils/logger.dart';
import 'package:firebase_database/firebase_database.dart';
import '../services/notification_service.dart';
import 'package:device_info_plus/device_info_plus.dart';

class AuthService {
  final HttpClient _httpClient = HttpClient();

  Future<ApiResponse<User>> login(String email, String password) async {
    try {
      // √ñnce eski kullanƒ±cƒ± verilerini temizle
      await _clearUserData();

      Logger.info('üîê LOGIN ATTEMPT: $email');
      Logger.debug(
        'üì§ Login Request Body: {"userEmail": "$email", "userPassword": "$password"}',
      );

      final response = await _httpClient.postWithBasicAuth(
        ApiConstants.login,
        body: {'userEmail': email, 'userPassword': password},
        useBasicAuth: true,
        fromJson: (json) {
          Logger.debug('üîç Login fromJson - Raw data: $json');

          // 410 response formatƒ±nƒ± kontrol et
          if (json['data'] != null &&
              json['data']['userID'] != null &&
              json['data']['token'] != null) {
            Logger.debug('‚úÖ Login - 410 response format detected');
            final userData = json['data'];

            // API'den gelen verilerle user objesi olu≈ütur
            final user = User(
              id: userData['userID'].toString(),
              name:
                  userData['userFirstname'] != null &&
                      userData['userLastname'] != null
                  ? '${userData['userFirstname']} ${userData['userLastname']}'
                  : userData['userName'] ?? 'Kullanƒ±cƒ±',
              firstName: userData['userFirstname'],
              lastName: userData['userLastname'],
              email: userData['userEmail'] ?? email,
              phone: userData['userPhone'],
              isVerified: userData['userVerified'] ?? false,
              isOnline: true,
              createdAt: userData['userCreatedAt'] != null
                  ? DateTime.tryParse(userData['userCreatedAt']) ??
                        DateTime.now()
                  : DateTime.now(),
              updatedAt: userData['userUpdatedAt'] != null
                  ? DateTime.tryParse(userData['userUpdatedAt']) ??
                        DateTime.now()
                  : DateTime.now(),
              token: userData['token'], // Token'ƒ± User nesnesine dahil et
            );

            return {'user': user, 'token': userData['token'] ?? ''};
          } else {
            // Standart format (eƒüer farklƒ± response gelirse)
            Logger.debug('‚úÖ Login - Standard response format');
            return {
              'user': User.fromJson(json['user']),
              'token': json['token'] ?? '',
            };
          }
        },
      );

      Logger.debug('üì• Response isSuccess: ${response.isSuccess}');
      Logger.debug('üì• Response data: ${response.data}');
      Logger.debug('üì• Response error: ${response.error}');

      if (response.isSuccess && response.data != null) {
        final data = response.data as Map<String, dynamic>;
        final user = data['user'] as User;
        final token = data['token'] as String;

        Logger.info('‚úÖ Login successful for user: ${user.id}');

        // Token ve kullanƒ±cƒ± bilgilerini kaydet
        await _saveUserData(user, token);

        // Login sonrasƒ±nda tam kullanƒ±cƒ± bilgilerini √ßek
        try {
          Logger.debug('üîÑ Fetching complete user profile after login...');
          final userService = UserService();
          final profileResponse = await userService.getUserProfile(
            userToken: token,
          );

          if (profileResponse.isSuccess && profileResponse.data != null) {
            final completeUser = profileResponse.data!;
            // Sadece ger√ßek user data'sƒ± varsa g√ºncelle (ID 0 deƒüilse)
            if (completeUser.id != '0' &&
                completeUser.email != 'user@example.com') {
              Logger.info('‚úÖ Complete user profile fetched successfully');
              await _saveUserDataOnly(completeUser);

              // Token'ƒ± her zaman g√ºncelle (API'den yeni token gelebilir)
              await _updateTokenIfNeeded(token);

              return ApiResponse.success(completeUser);
            } else {
              Logger.warning(
                '‚ö†Ô∏è Complete profile is default user, using login data instead',
              );
            }
          } else {
            Logger.warning(
              '‚ö†Ô∏è Failed to fetch complete profile, using login data',
            );
          }
        } catch (e) {
          Logger.warning(
            '‚ö†Ô∏è Error fetching complete profile: $e, using login data',
          );
        }

        // Token'ƒ± her zaman g√ºncelle
        await _updateTokenIfNeeded(token);

        return ApiResponse.success(user);
      }

      Logger.error('‚ùå Login failed: ${response.error}');
      return ApiResponse.error(response.error ?? ErrorMessages.unknownError);
    } catch (e) {
      Logger.error('üí• Login exception: $e', error: e);
      return ApiResponse.error(ErrorMessages.unknownError);
    }
  }

  Future<ApiResponse<User>> loginSocial({
    required String platform, // 'google' | 'apple'
    String? accessToken, // google
    String? idToken, // google ve apple i√ßin
    required String deviceID,
    String? fcmToken,
    String? devicePlatform, // 'ios', 'android', 'web'
  }) async {
    try {
      // Eski kullanƒ±cƒ± verilerini temizle
      await _clearUserData();

      final Map<String, dynamic> body = {
        'platform': platform,
        'deviceID': deviceID,
        'version': '1.0.0',
      };

      // devicePlatform parametresini ekle
      if (devicePlatform != null && devicePlatform.isNotEmpty) {
        body['devicePlatform'] = devicePlatform;
      } else {
        // Eƒüer devicePlatform verilmemi≈üse otomatik olarak tespit et
        final autoPlatform = await _getPlatform();
        body['devicePlatform'] = autoPlatform;
      }

      if (fcmToken != null && fcmToken.isNotEmpty) {
        body['fcmToken'] = fcmToken;
      }

      if (platform.toLowerCase() == 'google') {
        if (accessToken != null) {
          body['accessToken'] = accessToken;
        }
        if (idToken != null) {
          body['idToken'] = idToken;
        }
      }

      if (platform.toLowerCase() == 'apple' && idToken != null) {
        body['idToken'] = idToken;
      }

      Logger.info('üîê SOCIAL LOGIN ATTEMPT: $platform');
      Logger.debug('üì§ Social Login Request Body: ${json.encode(body)}');

      final response = await _httpClient.postWithBasicAuth(
        ApiConstants.loginSocial,
        body: body,
        useBasicAuth: true,
        fromJson: (json) {
          Logger.debug('üîç SocialLogin fromJson - Raw data: $json');

          // 410/200 format: data i√ßinde user ve token
          if (json is Map<String, dynamic>) {
            Map<String, dynamic>? dataField;
            if (json.containsKey('data') &&
                json['data'] is Map<String, dynamic>) {
              dataField = json['data'] as Map<String, dynamic>;
            } else {
              dataField = json; // bazƒ± durumlarda direkt d√∂nebilir
            }

            if (dataField['userID'] != null &&
                (dataField['token'] != null || json['token'] != null)) {
              final tokenString = (dataField['token'] ?? json['token'])
                  .toString();
              final user = User(
                id: dataField['userID'].toString(),
                name:
                    (dataField['userFirstname'] != null &&
                        dataField['userLastname'] != null)
                    ? '${dataField['userFirstname']} ${dataField['userLastname']}'
                    : dataField['userName']?.toString() ?? 'Kullanƒ±cƒ±',
                firstName: dataField['userFirstname']?.toString(),
                lastName: dataField['userLastname']?.toString(),
                email: dataField['userEmail']?.toString() ?? '',
                phone: dataField['userPhone']?.toString(),
                isVerified: (dataField['userVerified'] ?? false) == true,
                isOnline: true,
                createdAt: dataField['userCreatedAt'] != null
                    ? DateTime.tryParse(
                            dataField['userCreatedAt'].toString(),
                          ) ??
                          DateTime.now()
                    : DateTime.now(),
                updatedAt: DateTime.now(),
                token: tokenString,
              );

              return {'user': user, 'token': tokenString};
            }

            // Alternatif standart format
            if (json.containsKey('user')) {
              final user = User.fromJson(json['user']);
              final token = json['token']?.toString() ?? '';
              return {'user': user, 'token': token};
            }
          }

          return {
            'user': User(
              id: '0',
              name: 'Kullanƒ±cƒ±',
              firstName: null,
              lastName: null,
              email: 'user@example.com',
              phone: null,
              isVerified: false,
              isOnline: true,
              createdAt: DateTime.now(),
              updatedAt: DateTime.now(),
              token: '',
            ),
            'token': '',
          };
        },
      );

      if (response.isSuccess && response.data != null) {
        final data = response.data as Map<String, dynamic>;
        final user = data['user'] as User;
        final token = data['token'] as String? ?? '';

        if (token.isNotEmpty) {
          await _saveUserData(user, token);
          await _updateTokenIfNeeded(token);
        } else {
          // Bazƒ± sosyal login akƒ±≈ülarƒ±nda token body dƒ±≈üƒ±nda olabilir, yine de user'ƒ± kaydetme
          await _saveUserDataOnly(user);
        }

        return ApiResponse.success(user);
      }

      return ApiResponse.error(response.error ?? ErrorMessages.unknownError);
    } catch (e) {
      Logger.error('üí• Social login exception: $e', error: e);
      return ApiResponse.error(ErrorMessages.unknownError);
    }
  }

  Future<String> _getPlatform() async {
    try {
      if (Platform.isIOS) {
        return 'ios';
      } else if (Platform.isAndroid) {
        return 'android';
      } else {
        return 'web';
      }
    } catch (e) {
      return 'unknown';
    }
  }

  Future<ApiResponse<Map<String, dynamic>>> register({
    required String firstName,
    required String lastName,
    required String email,
    required String password,
    required String phone,
    required bool policy,
    required bool kvkk,
  }) async {
    try {
      final platform = await _getPlatform();

      Logger.info('üìù REGISTER ATTEMPT: $email');
      Logger.debug(
        'üì§ Register Request Body: {"userFirstname": "$firstName", "userLastname": "$lastName", "userEmail": "$email", "userPhone": "$phone", "userPassword": "$password", "version": "1.0", "platform": "$platform", "policy": $policy, "kvkk": $kvkk}',
      );

      final response = await _httpClient.postWithBasicAuth(
        ApiConstants.register,
        body: {
          'userFirstname': firstName,
          'userLastname': lastName,
          'userEmail': email,
          'userPhone': phone,
          'userPassword': password,
          'version': '1.0',
          'platform': platform,
          'policy': policy,
          'kvkk': kvkk,
        },
        useBasicAuth: true,
        fromJson: (json) {
          Logger.debug('üîç Register fromJson - Raw data: $json');

          // 410 response formatƒ±nƒ± kontrol et
          if (json['data'] != null && json['data']['userID'] != null) {
            Logger.debug('‚úÖ Register - 410 response format detected');
            final userData = json['data'];

            // API'den gelen verilerle user objesi olu≈ütur
            final tokenString =
                (userData['userToken'] ?? userData['token'] ?? '').toString();
            final user = User(
              id: userData['userID'].toString(),
              name:
                  userData['userFirstname'] != null &&
                      userData['userLastname'] != null
                  ? '${userData['userFirstname']} ${userData['userLastname']}'
                  : '$firstName $lastName',
              firstName: userData['userFirstname'] ?? firstName,
              lastName: userData['userLastname'] ?? lastName,
              email: userData['userEmail'] ?? email,
              phone: userData['userPhone'] ?? phone,
              isVerified:
                  userData['userVerified'] ??
                  false, // Email verification gerekli
              isOnline: true,
              createdAt: userData['userCreatedAt'] != null
                  ? DateTime.tryParse(userData['userCreatedAt']) ??
                        DateTime.now()
                  : DateTime.now(),
              updatedAt: userData['userUpdatedAt'] != null
                  ? DateTime.tryParse(userData['userUpdatedAt']) ??
                        DateTime.now()
                  : DateTime.now(),
              token: tokenString, // Token'ƒ± User nesnesine dahil et
            );

            Logger.debug(
              '‚úÖ User objesi olu≈üturuldu: ${user.id} - ${user.name}',
            );

            // codeToken'ƒ± da response'a ekle
            final result = {
              'user': user,
              'token':
                  tokenString, // Register'da token userToken olarak gelebilir
            };

            // codeToken varsa ekle
            if (userData.containsKey('codeToken') &&
                userData['codeToken'] != null) {
              result['codeToken'] = userData['codeToken'].toString();
              Logger.debug(
                'üîë CodeToken found in response: ${result['codeToken']}',
              );
            }

            return result;
          } else {
            // Standart format (eƒüer farklƒ± response gelirse)
            Logger.debug('‚úÖ Register - Standard response format');
            return {
              'user': User.fromJson(json['user']),
              'token': json['token'] ?? '',
            };
          }
        },
      );

      Logger.debug('üì• Register Response isSuccess: ${response.isSuccess}');
      Logger.debug('üì• Register Response data: ${response.data}');
      Logger.debug('üì• Register Response error: ${response.error}');

      if (response.isSuccess && response.data != null) {
        final data = response.data as Map<String, dynamic>;
        final user = data['user'] as User;
        final token = data['token'] as String;

        Logger.info('‚úÖ Register successful for user: ${user.id}');

        // Token ve kullanƒ±cƒ± bilgilerini kaydet
        await _saveUserData(user, token);
        Logger.debug(
          'üîë Token saved after register: ${token.substring(0, 10)}...',
        );

        // codeToken'ƒ± da kaydet (email verification i√ßin)
        if (data.containsKey('codeToken') && data['codeToken'] != null) {
          final codeToken = data['codeToken'].toString();
          Logger.debug('üîë CodeToken saved after register: $codeToken');
          // codeToken'ƒ± SharedPreferences'a kaydet
          final prefs = await SharedPreferences.getInstance();
          await prefs.setString('codeToken', codeToken);
        }

        // Register sonrasƒ±nda tam kullanƒ±cƒ± bilgilerini √ßek (token varsa)
        if (token.isNotEmpty) {
          try {
            Logger.debug('üîÑ Fetching complete user profile after register...');
            final userService = UserService();
            final profileResponse = await userService.getUserProfile(
              userToken: token,
            );

            if (profileResponse.isSuccess && profileResponse.data != null) {
              Logger.info('‚úÖ Complete user profile fetched successfully');
              final completeUser = profileResponse.data!;
              await _saveUserDataOnly(completeUser);

              // Token'ƒ± her zaman g√ºncelle (API'den yeni token gelebilir)
              await _updateTokenIfNeeded(token);

              // Kullanƒ±cƒ± verilerini SharedPreferences'a kaydet
              await _saveUserData(completeUser, token);

              return ApiResponse.success({
                'user': completeUser,
                'token': token,
                'codeToken': data['codeToken'],
              });
            } else {
              Logger.warning(
                '‚ö†Ô∏è Failed to fetch complete profile, using register data',
              );
            }
          } catch (e) {
            Logger.warning(
              '‚ö†Ô∏è Error fetching complete profile: $e, using register data',
            );
          }

          // Token'ƒ± her zaman g√ºncelle
          await _updateTokenIfNeeded(token);
        }

        // Kullanƒ±cƒ± verilerini SharedPreferences'a kaydet
        await _saveUserData(user, token);

        return ApiResponse.success({
          'user': user,
          'token': token,
          'codeToken': data['codeToken'],
        });
      }

      Logger.error('‚ùå Register failed: ${response.error}');
      return ApiResponse.error(response.error ?? ErrorMessages.unknownError);
    } catch (e) {
      Logger.error('üí• Register exception: $e', error: e);
      return ApiResponse.error(ErrorMessages.unknownError);
    }
  }

  Future<ApiResponse<Map<String, dynamic>?>> forgotPassword(
    String email,
  ) async {
    try {
      Logger.info('üîë FORGOT PASSWORD ATTEMPT: $email');
      Logger.debug('üì§ Forgot Password Request Body: {"userEmail": "$email"}');

      final response = await _httpClient.postWithBasicAuth(
        ApiConstants.forgotPassword,
        body: {'userEmail': email},
        useBasicAuth: true,
        fromJson: (json) {
          Logger.debug('üîç ForgotPassword fromJson - Raw data: $json');

          // API response'unda codeToken var mƒ± kontrol et
          if (json is Map<String, dynamic>) {
            final result = <String, dynamic>{};

            // T√ºm response verilerini logla
            Logger.debug(
              'üîç ForgotPassword response keys: ${json.keys.toList()}',
            );

            // codeToken varsa al (direkt response'ta veya data objesi i√ßinde)
            String? codeToken;
            if (json.containsKey('codeToken') && json['codeToken'] != null) {
              codeToken = json['codeToken'].toString();
              Logger.debug('üîë CodeToken found in response root: $codeToken');
            } else if (json.containsKey('data') &&
                json['data'] is Map<String, dynamic>) {
              final data = json['data'] as Map<String, dynamic>;
              if (data.containsKey('codeToken') && data['codeToken'] != null) {
                codeToken = data['codeToken'].toString();
                Logger.debug('üîë CodeToken found in data object: $codeToken');
              }
            }

            if (codeToken != null) {
              result['codeToken'] = codeToken;
            } else {
              Logger.warning(
                '‚ö†Ô∏è CodeToken not found in response or data object',
              );
            }

            // Mail bilgilerini de al
            if (json.containsKey('data') &&
                json['data'] is Map<String, dynamic>) {
              final data = json['data'] as Map<String, dynamic>;
              if (data.containsKey('mail') &&
                  data['mail'] is Map<String, dynamic>) {
                result['mail'] = data['mail'];
                Logger.debug('üìß Mail info found: ${data['mail']}');
              }
            }

            // Diƒüer response verilerini de al
            json.forEach((key, value) {
              if (key != 'codeToken' && key != 'data') {
                result[key] = value;
              }
            });

            Logger.debug('üîç Final result: $result');
            return result.isNotEmpty ? result : null;
          }

          Logger.warning('‚ö†Ô∏è Response is not a Map: ${json.runtimeType}');
          return null;
        },
      );

      Logger.debug(
        'üì• ForgotPassword Response isSuccess: ${response.isSuccess}',
      );
      Logger.debug('üì• ForgotPassword Response data: ${response.data}');
      Logger.debug('üì• ForgotPassword Response error: ${response.error}');

      if (response.isSuccess) {
        Logger.info('‚úÖ Forgot password request successful');
        return ApiResponse.success(response.data);
      }

      Logger.error('‚ùå Forgot password failed: ${response.error}');
      return ApiResponse.error(response.error ?? ErrorMessages.unknownError);
    } catch (e) {
      Logger.error('üí• Forgot password exception: $e', error: e);
      return ApiResponse.error(ErrorMessages.unknownError);
    }
  }

  Future<ApiResponse<bool>> checkEmailVerificationCode({
    required String code,
    required String codeToken,
  }) async {
    try {
      Logger.info('‚úÖ CHECK EMAIL CODE ATTEMPT: $codeToken');
      Logger.debug(
        'üì§ Check Code Request Body: {"code": "$code", "codeToken": "$codeToken"}',
      );

      final response = await _httpClient.postWithBasicAuth(
        ApiConstants.checkCode,
        body: {'code': code, 'codeToken': codeToken},
        useBasicAuth: true,
        fromJson: (json) {
          Logger.debug('üîç CheckCode fromJson - Raw data: $json');
          return null; // Email verification genelde sadece success/error d√∂ner
        },
      );

      Logger.debug('üì• CheckCode Response isSuccess:  {response.isSuccess}');
      Logger.debug('üì• CheckCode Response data: ${response.data}');
      Logger.debug('üì• CheckCode Response error: ${response.error}');

      if (response.isSuccess) {
        Logger.info('‚úÖ Email verification successful');

        // Kullanƒ±cƒ±nƒ±n isVerified durumunu g√ºncelle
        try {
          final currentUser = await getCurrentUser();
          if (currentUser != null) {
            final updatedUser = User(
              id: currentUser.id,
              name: currentUser.name,
              firstName: currentUser.firstName,
              lastName: currentUser.lastName,
              email: currentUser.email,
              phone: currentUser.phone,
              isVerified: true, // E-posta doƒürulandƒ±
              isOnline: currentUser.isOnline,
              createdAt: currentUser.createdAt,
              updatedAt: DateTime.now(),
              token: currentUser.token,
            );

            await _saveUserDataOnly(updatedUser);
            Logger.info('‚úÖ User verification status updated to true');
          }
        } catch (e) {
          Logger.warning('‚ö†Ô∏è Failed to update user verification status: $e');
        }

        return ApiResponse.success(true);
      }

      Logger.error('‚ùå Email verification failed: ${response.error}');
      return ApiResponse.error(response.error ?? ErrorMessages.unknownError);
    } catch (e) {
      Logger.error('üí• Check email code exception: $e', error: e);
      return ApiResponse.error(ErrorMessages.unknownError);
    }
  }

  Future<ApiResponse<Map<String, dynamic>?>> checkPasswordResetCode({
    required String code,
    required String email,
    required String codeToken,
  }) async {
    try {
      Logger.info('üîë CHECK PASSWORD RESET CODE ATTEMPT: $email');
      Logger.debug(
        'üì§ Check Password Reset Code Request Body: {"code": "$code", "userEmail": "$email", "codeToken": "$codeToken"}',
      );

      final response = await _httpClient.postWithBasicAuth(
        ApiConstants.checkCode,
        body: {'code': code, 'userEmail': email, 'codeToken': codeToken},
        useBasicAuth: true,
        fromJson: (json) {
          Logger.debug('üîç CheckPasswordResetCode fromJson - Raw data: $json');

          // API response'unda passToken var mƒ± kontrol et
          if (json is Map<String, dynamic>) {
            final result = <String, dynamic>{};

            // T√ºm response verilerini logla
            Logger.debug(
              'üîç CheckPasswordResetCode response keys: ${json.keys.toList()}',
            );

            // passToken varsa al (direkt response'ta veya data objesi i√ßinde)
            String? passToken;
            if (json.containsKey('passToken') && json['passToken'] != null) {
              passToken = json['passToken'].toString();
              Logger.debug('üîë PassToken found in response root: $passToken');
            } else if (json.containsKey('data') &&
                json['data'] is Map<String, dynamic>) {
              final data = json['data'] as Map<String, dynamic>;
              if (data.containsKey('passToken') && data['passToken'] != null) {
                passToken = data['passToken'].toString();
                Logger.debug('üîë PassToken found in data object: $passToken');
              }
            }

            if (passToken != null) {
              result['passToken'] = passToken;
            } else {
              Logger.warning(
                '‚ö†Ô∏è PassToken not found in response or data object',
              );
            }

            // Diƒüer response verilerini de al
            json.forEach((key, value) {
              if (key != 'passToken') {
                result[key] = value;
              }
            });

            Logger.debug('üîç Final result: $result');
            return result.isNotEmpty ? result : null;
          }

          Logger.warning('‚ö†Ô∏è Response is not a Map: ${json.runtimeType}');
          return null;
        },
      );

      Logger.debug(
        'üì• CheckPasswordResetCode Response isSuccess: ${response.isSuccess}',
      );
      Logger.debug('üì• CheckPasswordResetCode Response data: ${response.data}');
      Logger.debug(
        'üì• CheckPasswordResetCode Response error: ${response.error}',
      );

      if (response.isSuccess) {
        Logger.info('‚úÖ Password reset code verification successful');
        return ApiResponse.success(response.data);
      }

      Logger.error(
        '‚ùå Password reset code verification failed: ${response.error}',
      );
      return ApiResponse.error(response.error ?? ErrorMessages.unknownError);
    } catch (e) {
      Logger.error('üí• Check password reset code exception: $e', error: e);
      return ApiResponse.error(ErrorMessages.unknownError);
    }
  }

  Future<ApiResponse<Map<String, dynamic>?>> resendEmailVerificationCode({
    required String email,
  }) async {
    try {
      Logger.info('üîÑ RESEND EMAIL CODE ATTEMPT: $email');

      // Email validation
      if (email.trim().isEmpty) {
        Logger.error('‚ùå Email is empty');
        return ApiResponse.error('E-posta adresi bo≈ü olamaz');
      }

      // Email format validation
      final emailRegex = RegExp(r'^[^@]+@[^@]+\.[^@]+');
      if (!emailRegex.hasMatch(email)) {
        Logger.error('‚ùå Invalid email format: $email');
        return ApiResponse.error('Ge√ßersiz e-posta formatƒ±');
      }

      final requestBody = {'userEmail': email.trim()};
      Logger.debug('üì§ Resend Code Request Body: ${json.encode(requestBody)}');

      final response = await _httpClient.postWithBasicAuth(
        ApiConstants.againSendCode,
        body: requestBody,
        useBasicAuth: true,
        fromJson: (json) {
          Logger.debug('üîç ResendCode fromJson - Raw data: $json');

          // API response'unda codeToken var mƒ± kontrol et
          if (json is Map<String, dynamic>) {
            final result = <String, dynamic>{};

            // T√ºm response verilerini logla
            Logger.debug('üîç ResendCode response keys: ${json.keys.toList()}');

            // codeToken varsa al (direkt response'ta veya data objesi i√ßinde)
            String? codeToken;
            if (json.containsKey('codeToken') && json['codeToken'] != null) {
              codeToken = json['codeToken'].toString();
              Logger.debug('üîë CodeToken found in response root: $codeToken');
            } else if (json.containsKey('code_token') &&
                json['code_token'] != null) {
              codeToken = json['code_token'].toString();
              Logger.debug(
                'üîë CodeToken found in response root (snake): $codeToken',
              );
            } else if (json.containsKey('data') &&
                json['data'] is Map<String, dynamic>) {
              final data = json['data'] as Map<String, dynamic>;
              if (data.containsKey('codeToken') && data['codeToken'] != null) {
                codeToken = data['codeToken'].toString();
                Logger.debug('üîë CodeToken found in data object: $codeToken');
              } else if (data.containsKey('code_token') &&
                  data['code_token'] != null) {
                codeToken = data['code_token'].toString();
                Logger.debug(
                  'üîë CodeToken found in data object (snake): $codeToken',
                );
              } else if (data.containsKey('mail') &&
                  data['mail'] is Map<String, dynamic>) {
                final mail = data['mail'] as Map<String, dynamic>;
                if (mail['codeToken'] != null) {
                  codeToken = mail['codeToken'].toString();
                  Logger.debug('üîë CodeToken found in data.mail: $codeToken');
                } else if (mail['code_token'] != null) {
                  codeToken = mail['code_token'].toString();
                  Logger.debug(
                    'üîë CodeToken found in data.mail (snake): $codeToken',
                  );
                }
              }
            } else if (json.containsKey('mail') &&
                json['mail'] is Map<String, dynamic>) {
              final mail = json['mail'] as Map<String, dynamic>;
              if (mail['codeToken'] != null) {
                codeToken = mail['codeToken'].toString();
                Logger.debug('üîë CodeToken found in mail: $codeToken');
              } else if (mail['code_token'] != null) {
                codeToken = mail['code_token'].toString();
                Logger.debug('üîë CodeToken found in mail (snake): $codeToken');
              }
            }

            if (codeToken != null) {
              result['codeToken'] = codeToken;
            } else {
              Logger.warning(
                '‚ö†Ô∏è CodeToken not found in response or data object',
              );
            }

            // Diƒüer response verilerini de al
            json.forEach((key, value) {
              if (key != 'codeToken') {
                result[key] = value;
              }
            });

            Logger.debug('üîç Final result: $result');
            return result.isNotEmpty ? result : null;
          }

          Logger.warning('‚ö†Ô∏è Response is not a Map: ${json.runtimeType}');
          return null;
        },
      );

      Logger.debug('üì• ResendCode Response isSuccess: ${response.isSuccess}');
      Logger.debug('üì• ResendCode Response data: ${response.data}');
      Logger.debug('üì• ResendCode Response error: ${response.error}');

      if (response.isSuccess) {
        Logger.info('‚úÖ Resend email code successful');
        return ApiResponse.success(response.data);
      }

      Logger.error('‚ùå Resend email code failed: ${response.error}');
      return ApiResponse.error(response.error ?? ErrorMessages.unknownError);
    } catch (e) {
      Logger.error('üí• Resend email code exception: $e', error: e);
      return ApiResponse.error(ErrorMessages.unknownError);
    }
  }

  Future<ApiResponse<Map<String, dynamic>?>>
  resendEmailVerificationCodeWithToken({required String userToken}) async {
    try {
      Logger.info('üìß RESEND EMAIL VERIFICATION CODE WITH TOKEN ATTEMPT');

      // Token validation
      if (userToken.trim().isEmpty) {
        Logger.error('‚ùå User token is empty');
        return ApiResponse.error('Kullanƒ±cƒ± token\'ƒ± bo≈ü olamaz');
      }

      final requestBody = {'userToken': userToken.trim()};
      Logger.debug(
        'üì§ Resend Code with Token Request Body: ${json.encode(requestBody)}',
      );

      final response = await _httpClient.postWithBasicAuth(
        ApiConstants.againSendCode,
        body: requestBody,
        useBasicAuth: true,
        fromJson: (json) {
          Logger.debug('üîç ResendCode with Token fromJson - Raw data: $json');

          // API response'unda codeToken var mƒ± kontrol et
          if (json is Map<String, dynamic>) {
            final result = <String, dynamic>{};

            // T√ºm response verilerini logla
            Logger.debug(
              'üîç ResendCode with Token response keys: ${json.keys.toList()}',
            );

            // codeToken varsa al (direkt response'ta veya data objesi i√ßinde)
            String? codeToken;
            if (json.containsKey('codeToken') && json['codeToken'] != null) {
              codeToken = json['codeToken'].toString();
              Logger.debug('üîë CodeToken found in response root: $codeToken');
            } else if (json.containsKey('code_token') &&
                json['code_token'] != null) {
              codeToken = json['code_token'].toString();
              Logger.debug(
                'üîë CodeToken found in response root (snake): $codeToken',
              );
            } else if (json.containsKey('data') &&
                json['data'] is Map<String, dynamic>) {
              final data = json['data'] as Map<String, dynamic>;
              if (data.containsKey('codeToken') && data['codeToken'] != null) {
                codeToken = data['codeToken'].toString();
                Logger.debug('üîë CodeToken found in data object: $codeToken');
              } else if (data.containsKey('code_token') &&
                  data['code_token'] != null) {
                codeToken = data['code_token'].toString();
                Logger.debug(
                  'üîë CodeToken found in data object (snake): $codeToken',
                );
              } else if (data.containsKey('mail') &&
                  data['mail'] is Map<String, dynamic>) {
                final mail = data['mail'] as Map<String, dynamic>;
                if (mail['codeToken'] != null) {
                  codeToken = mail['codeToken'].toString();
                  Logger.debug('üîë CodeToken found in data.mail: $codeToken');
                } else if (mail['code_token'] != null) {
                  codeToken = mail['code_token'].toString();
                  Logger.debug(
                    'üîë CodeToken found in data.mail (snake): $codeToken',
                  );
                }
              }
            } else if (json.containsKey('mail') &&
                json['mail'] is Map<String, dynamic>) {
              final mail = json['mail'] as Map<String, dynamic>;
              if (mail['codeToken'] != null) {
                codeToken = mail['codeToken'].toString();
                Logger.debug('üîë CodeToken found in mail: $codeToken');
              } else if (mail['code_token'] != null) {
                codeToken = mail['code_token'].toString();
                Logger.debug('üîë CodeToken found in mail (snake): $codeToken');
              }
            }

            if (codeToken != null) {
              result['codeToken'] = codeToken;
            } else {
              Logger.warning(
                '‚ö†Ô∏è CodeToken not found in response or data object',
              );
            }

            // Diƒüer response verilerini de al
            json.forEach((key, value) {
              if (key != 'codeToken') {
                result[key] = value;
              }
            });

            Logger.debug('üîç Final result with token: $result');
            return result.isNotEmpty ? result : null;
          }

          Logger.warning(
            '‚ö†Ô∏è Response with token is not a Map: ${json.runtimeType}',
          );
          return null;
        },
      );

      Logger.debug(
        'üì• ResendCode with Token Response isSuccess: ${response.isSuccess}',
      );
      Logger.debug('üì• ResendCode with Token Response data: ${response.data}');
      Logger.debug(
        'üì• ResendCode with Token Response error: ${response.error}',
      );

      if (response.isSuccess) {
        Logger.info('‚úÖ Resend email code with token successful');
        return ApiResponse.success(response.data);
      }

      Logger.error('‚ùå Resend email code with token failed: ${response.error}');
      return ApiResponse.error(response.error ?? ErrorMessages.unknownError);
    } catch (e) {
      Logger.error('üí• Resend email code with token exception: $e', error: e);
      return ApiResponse.error(ErrorMessages.unknownError);
    }
  }

  Future<ApiResponse<void>> updatePassword({
    required String passToken,
    required String password,
    required String passwordAgain,
  }) async {
    Logger.info('üîí UPDATE PASSWORD ATTEMPT with passToken');

    // updatePassword metodunu changePassword metoduna y√∂nlendir
    return await changePassword(
      passToken: passToken,
      password: password,
      passwordAgain: passwordAgain,
    );
  }

  Future<ApiResponse<void>> changePassword({
    required String passToken,
    required String password,
    required String passwordAgain,
  }) async {
    try {
      Logger.info('üîí CHANGE PASSWORD ATTEMPT with passToken');
      Logger.debug(
        'üì§ Change Password Request Body: {"passToken": "$passToken", "password": "$password", "passwordAgain": "$passwordAgain"}',
      );

      final response = await _httpClient.postWithBasicAuth(
        ApiConstants.changePassword,
        body: {
          'passToken': passToken,
          'password': password,
          'passwordAgain': passwordAgain,
        },
        useBasicAuth: true,
        fromJson: (json) {
          Logger.debug('üîç ChangePassword fromJson - Raw data: $json');
          return null; // Change password genelde sadece success/error d√∂ner
        },
      );

      Logger.debug(
        'üì• ChangePassword Response isSuccess: ${response.isSuccess}',
      );
      Logger.debug('üì• ChangePassword Response data: ${response.data}');
      Logger.debug('üì• ChangePassword Response error: ${response.error}');

      if (response.isSuccess) {
        Logger.info('‚úÖ Password change successful');
        return ApiResponse.success(null);
      }

      Logger.error('‚ùå Password change failed: ${response.error}');
      return ApiResponse.error(response.error ?? ErrorMessages.unknownError);
    } catch (e) {
      Logger.error('üí• Change password exception: $e', error: e);
      return ApiResponse.error(ErrorMessages.unknownError);
    }
  }

  // Direkt ≈üifre deƒüi≈ütirme (e-posta doƒürulamasƒ± olmadan)
  Future<ApiResponse<void>> updateUserPassword({
    required String currentPassword,
    required String newPassword,
    required String newPasswordAgain,
  }) async {
    try {
      Logger.info('üîí UPDATE USER PASSWORD ATTEMPT (direct)');

      // Mevcut kullanƒ±cƒ±nƒ±n token'ƒ±nƒ± al
      final userToken = await getCurrentUserToken();
      if (userToken == null || userToken.isEmpty) {
        Logger.error('‚ùå User token not found');
        return ApiResponse.error(
          'Kullanƒ±cƒ± token\'ƒ± bulunamadƒ±. L√ºtfen tekrar giri≈ü yapƒ±n.',
        );
      }

      Logger.debug(
        'üì§ Update User Password Request Body: {"passToken": "${userToken.substring(0, 10)}...", "password": "${newPassword.length} chars", "passwordAgain": "${newPasswordAgain.length} chars"}',
      );

      final response = await _httpClient.postWithBasicAuth(
        ApiConstants.changePassword,
        body: {
          'passToken': userToken, // Mevcut kullanƒ±cƒ±nƒ±n token'ƒ±nƒ± kullan
          'password': newPassword,
          'passwordAgain': newPasswordAgain,
        },
        useBasicAuth: true,
        fromJson: (json) {
          Logger.debug('üîç UpdateUserPassword fromJson - Raw data: $json');
          return null; // Update password genelde sadece success/error d√∂ner
        },
      );

      Logger.debug(
        'üì• UpdateUserPassword Response isSuccess: ${response.isSuccess}',
      );
      Logger.debug('üì• UpdateUserPassword Response data: ${response.data}');
      Logger.debug('üì• UpdateUserPassword Response error: ${response.error}');

      if (response.isSuccess) {
        Logger.info('‚úÖ User password update successful');
        return ApiResponse.success(null);
      }

      Logger.error('‚ùå User password update failed: ${response.error}');
      return ApiResponse.error(response.error ?? ErrorMessages.unknownError);
    } catch (e) {
      Logger.error('üí• Update user password exception: $e', error: e);
      return ApiResponse.error(ErrorMessages.unknownError);
    }
  }

  Future<ApiResponse<User>> getProfile() async {
    try {
      final response = await _httpClient.get(
        ApiConstants.profile,
        fromJson: (json) {
          // Token g√ºncelleme kontrol√º - API'den yeni token gelirse kaydet
          if (json is Map<String, dynamic>) {
            if (json.containsKey('token') &&
                json['token'] != null &&
                json['token'].toString().isNotEmpty) {
              final newToken = json['token'].toString();
              Logger.debug(
                'üîÑ Get Profile - API response\'unda yeni token bulundu: ${newToken.substring(0, 20)}...',
              );
              _updateTokenIfNeeded(newToken);
            }

            // Data i√ßinde token kontrol√º
            if (json.containsKey('data') &&
                json['data'] is Map<String, dynamic>) {
              final data = json['data'] as Map<String, dynamic>;
              if (data.containsKey('token') &&
                  data['token'] != null &&
                  data['token'].toString().isNotEmpty) {
                final newToken = data['token'].toString();
                Logger.debug(
                  'üîÑ Get Profile - Data field i√ßinde yeni token bulundu: ${newToken.substring(0, 20)}...',
                );
                _updateTokenIfNeeded(newToken);
              }
            }
          }

          return User.fromJson(json);
        },
      );

      if (response.isSuccess && response.data != null) {
        // G√ºncel kullanƒ±cƒ± bilgilerini kaydet
        await _saveUserDataOnly(response.data!);
      }

      return response;
    } catch (e) {
      return ApiResponse.error(ErrorMessages.unknownError);
    }
  }

  Future<ApiResponse<User>> updateProfile({
    String? name,
    String? phone,
    String? bio,
    String? avatar,
  }) async {
    try {
      final body = <String, dynamic>{};
      if (name != null) body['name'] = name;
      if (phone != null) body['phone'] = phone;
      if (bio != null) body['bio'] = bio;
      if (avatar != null) body['avatar'] = avatar;

      final response = await _httpClient.put(
        ApiConstants.profile,
        body: body,
        fromJson: (json) {
          // Token g√ºncelleme kontrol√º - API'den yeni token gelirse kaydet
          if (json is Map<String, dynamic>) {
            if (json.containsKey('token') &&
                json['token'] != null &&
                json['token'].toString().isNotEmpty) {
              final newToken = json['token'].toString();
              Logger.debug(
                'üîÑ Update Profile - API response\'unda yeni token bulundu: ${newToken.substring(0, 20)}...',
              );
              _updateTokenIfNeeded(newToken);
            }

            // Data i√ßinde token kontrol√º
            if (json.containsKey('data') &&
                json['data'] is Map<String, dynamic>) {
              final data = json['data'] as Map<String, dynamic>;
              if (data.containsKey('token') &&
                  data['token'] != null &&
                  data['token'].toString().isNotEmpty) {
                final newToken = data['token'].toString();
                Logger.debug(
                  'üîÑ Update Profile - Data field i√ßinde yeni token bulundu: ${newToken.substring(0, 20)}...',
                );
                _updateTokenIfNeeded(newToken);
              }
            }
          }

          return User.fromJson(json);
        },
      );

      if (response.isSuccess && response.data != null) {
        // G√ºncel kullanƒ±cƒ± bilgilerini kaydet
        await _saveUserDataOnly(response.data!);
      }

      return response;
    } catch (e) {
      return ApiResponse.error(ErrorMessages.unknownError);
    }
  }

  Future<ApiResponse<void>> logout() async {
    try {
      Logger.debug('üö™ AuthService.logout called');

      // API √ßaƒürƒ±sƒ± yapmadan direkt local verileri temizle
      await _clearUserData();

      Logger.debug('‚úÖ AuthService.logout - Local data cleared successfully');
      return ApiResponse.success(null);
    } catch (e) {
      Logger.error('‚ùå AuthService.logout - Exception: $e', error: e);
      return ApiResponse.error(ErrorMessages.unknownError);
    }
  }

  Future<String?> getToken() async {
    try {
      Logger.debug('üîë AuthService.getToken called');
      final prefs = await SharedPreferences.getInstance();
      final token = prefs.getString(AppConstants.userTokenKey);

      if (token != null) {
        Logger.debug(
          '‚úÖ AuthService.getToken - Token found: ${token.substring(0, 20)}...',
        );
      } else {
        Logger.debug('‚ùå AuthService.getToken - No token found');
      }

      return token;
    } catch (e) {
      Logger.error('‚ùå AuthService.getToken - Exception: $e', error: e);
      return null;
    }
  }

  Future<User?> getCurrentUser() async {
    try {
      Logger.info('üë§ AuthService.getCurrentUser - Quick fetch for hot reload');
      final prefs = await SharedPreferences.getInstance();
      final userDataString = prefs.getString(AppConstants.userDataKey);

      if (userDataString != null && userDataString.isNotEmpty) {
        Logger.debug(
          '‚úÖ AuthService.getCurrentUser - User data found, length: ${userDataString.length}',
        );
        final userData = json.decode(userDataString);
        final user = User.fromJson(userData);
        Logger.info(
          '‚úÖ AuthService.getCurrentUser - User loaded: ${user.id} - ${user.name}',
        );
        return user;
      }

      Logger.warning('‚ùå AuthService.getCurrentUser - No user data found');
      return null;
    } catch (e) {
      Logger.error('‚ùå AuthService.getCurrentUser - Exception: $e', error: e);
      return null;
    }
  }

  Future<void> _saveUserData(User user, String token) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      Logger.debug(
        'üîç _saveUserData - User object: id=${user.id}, name=${user.name}, email=${user.email}',
      );
      Logger.debug('üîç _saveUserData - User.toJson(): ${user.toJson()}');

      if (user.id.isNotEmpty && token.isNotEmpty) {
        Logger.debug(
          'Login sonrasƒ± userId kaydediliyor: [${user.id}], token: [${token.substring(0, 10)}...]',
        );
        await prefs.setString(AppConstants.userTokenKey, token);
        await prefs.setString(AppConstants.userIdKey, user.id);
        await prefs.setString(
          AppConstants.userDataKey,
          json.encode(user.toJson()),
        );

        // FCM token'ƒ± Firebase'e kaydet - async olarak √ßalƒ±≈ütƒ±r
        _saveFCMTokenToFirebase(user.id)
            .then((_) {
              Logger.info('‚úÖ FCM token Firebase\'e kaydetme tamamlandƒ±');
            })
            .catchError((error) {
              Logger.error(
                '‚ùå FCM token Firebase\'e kaydetme hatasƒ±: $error',
                error: error,
              );
            });

        // Kaydetme sonrasƒ± kontrol
        final savedUserId = prefs.getString(AppConstants.userIdKey);
        Logger.debug(
          'üîç _saveUserData - Saved and retrieved userId: [$savedUserId]',
        );
      } else {
        Logger.error(
          'HATA: Login sonrasƒ± userId veya token null/bo≈ü! userId: [${user.id}], token: [$token]',
        );
      }
    } catch (e) {
      Logger.error('‚ùå _saveUserData - Exception: $e', error: e);
    }
  }

  // FCM token'ƒ± Firebase'e kaydet
  Future<void> _saveFCMTokenToFirebase(String userId) async {
    try {
      Logger.info('üîÑ FCM token Firebase\'e kaydediliyor...');
      Logger.info('üë§ User ID: $userId');

      // NotificationService'ten FCM token'ƒ± al
      final fcmToken = await NotificationService.instance.getFCMToken();

      if (fcmToken != null && fcmToken.isNotEmpty) {
        Logger.info('‚úÖ FCM token alƒ±ndƒ±: ${fcmToken.substring(0, 20)}...');

        // Firebase Database'e FCM token'ƒ± kaydet
        final database = FirebaseDatabase.instance.ref();

        // Cihaz bilgisi ile birlikte FCM token'ƒ± kaydet
        final deviceInfo = await _getDeviceInfo();
        final path = 'users/$userId/fcmToken';

        Logger.info(
          'üìù FCM token kaydediliyor: $path = ${fcmToken.substring(0, 20)}...',
        );
        Logger.info('üì± Cihaz bilgisi: $deviceInfo');

        // Token ve cihaz bilgisini birlikte kaydet
        final tokenData = {
          'token': fcmToken,
          'deviceInfo': deviceInfo,
          'lastUpdated': DateTime.now().millisecondsSinceEpoch,
        };

        await database.child(path).set(tokenData);
        Logger.info('‚úÖ FCM token ve cihaz bilgisi Firebase\'e kaydedildi');

        // Kaydedilen token'ƒ± kontrol et
        final savedToken = await database.child(path).get();
        if (savedToken.value != null) {
          final savedValue = savedToken.value.toString();
          Logger.info(
            '‚úÖ FCM token ba≈üarƒ±yla Firebase\'e kaydedildi ve doƒürulandƒ±: ${fcmToken.substring(0, 20)}...',
          );

          // Token'ƒ± SharedPreferences'a kaydet
          final prefs = await SharedPreferences.getInstance();
          await prefs.setString('fcmToken', fcmToken);
          Logger.info('‚úÖ FCM token SharedPreferences\'a kaydedildi');
        } else {
          Logger.error('‚ùå FCM token kaydedildi ama doƒürulanamadƒ±!');
        }
      } else {
        Logger.warning('‚ö†Ô∏è FCM token alƒ±namadƒ±, Firebase\'e kaydedilmedi');

        // FCM token alƒ±namadƒ±ysa tekrar deneme
        await Future.delayed(Duration(seconds: 2));
        final retryToken = await NotificationService.instance.getFCMToken();
        if (retryToken != null && retryToken.isNotEmpty) {
          Logger.info(
            'üîÑ FCM token retry ile alƒ±ndƒ±, tekrar kaydetme deneniyor...',
          );
          await _saveFCMTokenToFirebase(userId);
        }
      }
    } catch (e) {
      Logger.error('‚ùå FCM token Firebase\'e kaydetme hatasƒ±: $e', error: e);

      // Hata durumunda tekrar deneme
      try {
        await Future.delayed(Duration(seconds: 3));
        Logger.info('üîÑ FCM token kaydetme hatasƒ± sonrasƒ± tekrar deneniyor...');
        await _saveFCMTokenToFirebase(userId);
      } catch (retryError) {
        Logger.error(
          '‚ùå FCM token kaydetme retry hatasƒ±: $retryError',
          error: retryError,
        );
      }
    }
  }

  // Cihaz bilgisini al
  Future<String> _getDeviceInfo() async {
    try {
      final deviceInfo = DeviceInfoPlugin();
      String deviceId = 'unknown';

      if (Platform.isAndroid) {
        final androidInfo = await deviceInfo.androidInfo;
        deviceId =
            '${androidInfo.brand}_${androidInfo.model}_${androidInfo.id}';
      } else if (Platform.isIOS) {
        final iosInfo = await deviceInfo.iosInfo;
        deviceId =
            '${iosInfo.name}_${iosInfo.model}_${iosInfo.identifierForVendor}';
      }

      return deviceId;
    } catch (e) {
      Logger.warning('‚ö†Ô∏è Cihaz bilgisi alƒ±namadƒ±: $e');
      return 'unknown_device';
    }
  }

  Future<void> _saveUserDataOnly(User user) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      if (user.id.isNotEmpty) {
        Logger.debug(
          'Profil g√ºncelleme sonrasƒ± userId kaydediliyor: ${user.id}',
        );
        await prefs.setString(AppConstants.userIdKey, user.id);
      } else {
        Logger.debug(
          'Profil g√ºncelleme sonrasƒ± userId bo≈ü, eski id korunuyor.',
        );
      }

      // Mevcut token'ƒ± koru
      final currentToken = prefs.getString(AppConstants.userTokenKey);
      if (currentToken != null && user.token == null) {
        user = user.copyWith(token: currentToken);
      }

      await prefs.setString(
        AppConstants.userDataKey,
        json.encode(user.toJson()),
      );
    } catch (e) {
      // Hata durumunda sessizce ge√ß
    }
  }

  /// Token'ƒ± SharedPreferences'a g√ºnceller
  Future<void> _updateTokenIfNeeded(String newToken) async {
    try {
      if (newToken.isNotEmpty) {
        final prefs = await SharedPreferences.getInstance();
        final currentToken = prefs.getString(AppConstants.userTokenKey);

        // Token farklƒ±ysa veya yoksa g√ºncelle
        if (currentToken != newToken) {
          Logger.debug(
            'üîÑ Token g√ºncelleniyor: ${newToken.substring(0, 20)}...',
          );
          await prefs.setString(AppConstants.userTokenKey, newToken);
          Logger.debug('‚úÖ Token ba≈üarƒ±yla g√ºncellendi');
        } else {
          Logger.debug('‚ÑπÔ∏è Token zaten g√ºncel, g√ºncelleme gerekmiyor');
        }
      } else {
        Logger.warning('‚ö†Ô∏è Bo≈ü token, g√ºncelleme yapƒ±lmadƒ±');
      }
    } catch (e) {
      Logger.error('‚ùå Token g√ºncelleme hatasƒ±: $e', error: e);
    }
  }

  Future<void> _clearUserData() async {
    try {
      final prefs = await SharedPreferences.getInstance();

      await prefs.remove(AppConstants.userTokenKey);
      await prefs.remove(AppConstants.userIdKey);
      await prefs.remove(AppConstants.userDataKey);
    } catch (e) {
      // Hata durumunda sessizce ge√ß
    }
  }

  Future<String?> getCurrentUserId() async {
    try {
      Logger.debug('üîÑ AuthService.getCurrentUserId called');
      final prefs = await SharedPreferences.getInstance();

      // T√ºm kaydedilmi≈ü key'leri kontrol et
      final allKeys = prefs.getKeys();
      Logger.debug('üîç AuthService - All SharedPreferences keys: $allKeys');

      final userId = prefs.getString(AppConstants.userIdKey);
      final userToken = prefs.getString(AppConstants.userTokenKey);
      final userData = prefs.getString(AppConstants.userDataKey);

      Logger.debug(
        'üîç AuthService - AppConstants.userIdKey: ${AppConstants.userIdKey}',
      );
      Logger.debug('üîç AuthService - Retrieved user ID: [$userId]');
      Logger.debug(
        'üîç AuthService - Retrieved user token: ${userToken?.substring(0, 10)}...',
      );
      Logger.debug(
        'üîç AuthService - Retrieved user data length: ${userData?.length}',
      );

      // User data'yƒ± parse edip ID'yi kontrol et
      if (userData != null) {
        try {
          final userJson = json.decode(userData);
          final userIdFromData = userJson['id'];
          Logger.debug(
            'üîç AuthService - User ID from userData: [$userIdFromData]',
          );
          Logger.debug('üîç AuthService - Full userData: $userJson');

          // Eƒüer userData'daki ID farklƒ±ysa, onu kullan
          if (userIdFromData != null &&
              userIdFromData.toString() != '0' &&
              userId == '0') {
            Logger.debug(
              'üîß AuthService - Using ID from userData instead: [$userIdFromData]',
            );
            return userIdFromData.toString();
          }
        } catch (e) {
          Logger.error('‚ùå AuthService - Error parsing userData: $e', error: e);
        }
      }

      return userId;
    } catch (e) {
      Logger.error(
        '‚ùå AuthService - Error getting current user ID: $e',
        error: e,
      );
      return null;
    }
  }

  Future<bool> isLoggedIn() async {
    try {
      Logger.info('üîç AuthService.isLoggedIn - Quick check for hot reload');
      final prefs = await SharedPreferences.getInstance();
      final token = prefs.getString(AppConstants.userTokenKey);
      final userId = prefs.getString(AppConstants.userIdKey);

      Logger.debug(
        'üîç AuthService.isLoggedIn - userId=[$userId], token=[${token?.substring(0, token.length > 10 ? 10 : token.length)}...]',
      );

      final isLoggedIn =
          token != null &&
          token.isNotEmpty &&
          userId != null &&
          userId.isNotEmpty;

      Logger.info('üîç AuthService.isLoggedIn - Result: $isLoggedIn');
      return isLoggedIn;
    } catch (e) {
      Logger.error('‚ùå AuthService.isLoggedIn - Exception: $e', error: e);
      return false;
    }
  }

  // Mevcut kullanƒ±cƒ±nƒ±n token'ƒ±nƒ± al
  Future<String?> getCurrentUserToken() async {
    try {
      Logger.debug('üîç AuthService.getCurrentUserToken called');
      final prefs = await SharedPreferences.getInstance();
      final token = prefs.getString(AppConstants.userTokenKey);

      Logger.debug(
        'üîç AuthService.getCurrentUserToken - token=[${token?.substring(0, token.length > 10 ? 10 : token.length)}...]',
      );

      return token;
    } catch (e) {
      Logger.error(
        '‚ùå AuthService.getCurrentUserToken - Exception: $e',
        error: e,
      );
      return null;
    }
  }

  // Kayƒ±t sonrasƒ± alƒ±nan codeToken'ƒ± al
  Future<String?> getStoredCodeToken() async {
    try {
      Logger.debug('üîç AuthService.getStoredCodeToken called');
      final prefs = await SharedPreferences.getInstance();
      final codeToken = prefs.getString('codeToken');

      if (codeToken != null && codeToken.isNotEmpty) {
        Logger.debug('‚úÖ CodeToken found: $codeToken');
      } else {
        Logger.debug('‚ùå No codeToken found');
      }

      return codeToken;
    } catch (e) {
      Logger.error(
        '‚ùå AuthService.getStoredCodeToken - Exception: $e',
        error: e,
      );
      return null;
    }
  }

  // codeToken'ƒ± temizle (kullanƒ±ldƒ±ktan sonra)
  Future<void> clearStoredCodeToken() async {
    try {
      Logger.debug('üßπ Clearing stored codeToken');
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('codeToken');
      Logger.debug('‚úÖ CodeToken cleared');
    } catch (e) {
      Logger.error('‚ùå Error clearing codeToken: $e', error: e);
    }
  }

  /// FCM token'larƒ± temizler
  Future<void> clearFCMTokens() async {
    try {
      Logger.info('üßπ FCM token\'lar temizleniyor...');

      final database = FirebaseDatabase.instance.ref();

      // T√ºm kullanƒ±cƒ±lardaki FCM token'larƒ± temizle
      final allUsersSnapshot = await database.child('users').get();
      if (allUsersSnapshot.value != null) {
        dynamic rawValue = allUsersSnapshot.value;
        Map<String, dynamic>? allUsers;

        if (rawValue is Map) {
          allUsers = Map<String, dynamic>.from(rawValue);
        } else if (rawValue is List) {
          allUsers = <String, dynamic>{};
          for (int i = 0; i < rawValue.length; i++) {
            if (rawValue[i] != null) {
              allUsers[i.toString()] = rawValue[i];
            }
          }
        }

        if (allUsers != null) {
          Logger.info('üîç Firebase\'de ${allUsers.length} kullanƒ±cƒ± bulundu');

          for (final entry in allUsers.entries) {
            final userId = entry.key;
            final userData = entry.value;

            Logger.info('üîç Kullanƒ±cƒ± $userId kontrol ediliyor...');

            if (userData is Map && userData.containsKey('fcmToken')) {
              final fcmToken = userData['fcmToken'] as String;
              Logger.info(
                'üßπ Kullanƒ±cƒ± $userId\'den FCM token temizleniyor: ${fcmToken.substring(0, 20)}...',
              );

              await database.child('users/$userId/fcmToken').remove();
              Logger.info('‚úÖ Kullanƒ±cƒ± $userId\'den FCM token temizlendi');
            } else {
              Logger.info('‚ÑπÔ∏è Kullanƒ±cƒ± $userId\'de FCM token yok');
            }
          }
        }
      }

      Logger.info('‚úÖ T√ºm FCM token\'lar temizlendi!');
    } catch (e) {
      Logger.error('‚ùå FCM token temizleme hatasƒ±: $e', error: e);
    }
  }

  /// FCM token'ƒ± test etmek i√ßin kullanƒ±lƒ±r
  Future<void> testFCMToken() async {
    try {
      Logger.info('üß™ FCM token test ba≈ülatƒ±lƒ±yor...');

      // Mevcut kullanƒ±cƒ± bilgilerini kontrol et
      final prefs = await SharedPreferences.getInstance();
      final userId = prefs.getString(AppConstants.userIdKey);
      final userToken = prefs.getString(AppConstants.userTokenKey);
      final fcmToken = prefs.getString('fcmToken');

      Logger.info('üîç Mevcut kullanƒ±cƒ± bilgileri:');
      Logger.info('üë§ User ID: [$userId]');
      Logger.info('üîë User Token: [${userToken?.substring(0, 10)}...]');
      Logger.info('üì± FCM Token: [${fcmToken?.substring(0, 20)}...]');

      if (userId != null && userId.isNotEmpty) {
        Logger.info('‚úÖ Kullanƒ±cƒ± ID bulundu: $userId');

        // Sadece mevcut kullanƒ±cƒ±ya FCM token kaydet (temizlik yapma)
        Logger.info('üìù Kullanƒ±cƒ± $userId i√ßin FCM token kaydediliyor...');
        await _saveFCMTokenToFirebase(userId);

        Logger.info('‚úÖ FCM token ba≈üarƒ±yla kaydedildi!');
      } else {
        Logger.warning('‚ö†Ô∏è Kullanƒ±cƒ± ID bulunamadƒ±, FCM token kaydedilemedi');
      }
    } catch (e) {
      Logger.error('‚ùå FCM token test hatasƒ±: $e', error: e);
    }
  }

  /// Token'ƒ±n ge√ßerli olup olmadƒ±ƒüƒ±nƒ± kontrol eder
  Future<bool> isTokenValid() async {
    try {
      Logger.info('üîç AuthService.isTokenValid - Checking token validity');

      final token = await getToken();
      if (token == null || token.isEmpty) {
        Logger.warning('‚ö†Ô∏è AuthService.isTokenValid - No token found');
        return false;
      }

      // UserService ile profile √ßekmeye √ßalƒ±≈üarak token'ƒ± test et
      final userService = UserService();
      final response = await userService.getUserProfile(userToken: token);

      if (response.isSuccess && response.data != null) {
        Logger.info('‚úÖ AuthService.isTokenValid - Token is valid');
        return true;
      } else {
        Logger.warning(
          '‚ö†Ô∏è AuthService.isTokenValid - Token is invalid: ${response.error}',
        );

        // Token ge√ßersizse kullanƒ±cƒ± verilerini temizle
        if (response.error != null &&
            (response.error!.contains('token') ||
                response.error!.contains('401') ||
                response.error!.contains('403') ||
                response.error!.contains('Ge√ßersiz') ||
                response.error!.contains('doƒürulama'))) {
          Logger.info(
            'üßπ AuthService.isTokenValid - Clearing invalid token data',
          );
          await _clearUserData();
        }

        return false;
      }
    } catch (e) {
      Logger.error('‚ùå AuthService.isTokenValid - Exception: $e', error: e);
      return false;
    }
  }

  // FCM token'ƒ± debug et
  Future<void> debugFCMToken(String userId) async {
    try {
      Logger.info('üîç FCM token debug ba≈ülatƒ±lƒ±yor...', tag: 'AuthService');

      // 1. SharedPreferences'dan token al
      final prefs = await SharedPreferences.getInstance();
      final localToken = prefs.getString('fcmToken');
      Logger.info(
        'üì± Local FCM token: ${localToken != null ? '${localToken.substring(0, 20)}...' : 'null'}',
        tag: 'AuthService',
      );

      // 2. NotificationService'den token al
      final notificationToken = await NotificationService.instance
          .getFCMToken();
      Logger.info(
        'üîî NotificationService FCM token: ${notificationToken != null ? '${notificationToken.substring(0, 20)}...' : 'null'}',
        tag: 'AuthService',
      );

      // 3. Firebase'den token al
      final database = FirebaseDatabase.instance.ref();
      final firebaseTokenSnapshot = await database
          .child('users/$userId/fcmToken')
          .get();
      final firebaseToken = firebaseTokenSnapshot.value?.toString();
      Logger.info(
        'üî• Firebase FCM token: ${firebaseToken != null ? '${firebaseToken.substring(0, 20)}...' : 'null'}',
        tag: 'AuthService',
      );

      // 4. Token'larƒ± kar≈üƒ±la≈ütƒ±r
      if (localToken == notificationToken &&
          notificationToken == firebaseToken) {
        Logger.info('‚úÖ T√ºm FCM token\'lar e≈üle≈üiyor', tag: 'AuthService');
      } else {
        Logger.warning('‚ö†Ô∏è FCM token\'lar e≈üle≈ümiyor!', tag: 'AuthService');
        Logger.warning(
          'üì± Local: ${localToken?.substring(0, 20)}...',
          tag: 'AuthService',
        );
        Logger.warning(
          'üîî Notification: ${notificationToken?.substring(0, 20)}...',
          tag: 'AuthService',
        );
        Logger.warning(
          'üî• Firebase: ${firebaseToken?.substring(0, 20)}...',
          tag: 'AuthService',
        );

        // Firebase'deki token'ƒ± g√ºncelle
        if (notificationToken != null && notificationToken.isNotEmpty) {
          Logger.info(
            'üîÑ Firebase\'deki FCM token g√ºncelleniyor...',
            tag: 'AuthService',
          );
          await database.child('users/$userId/fcmToken').set(notificationToken);
          Logger.info('‚úÖ Firebase FCM token g√ºncellendi', tag: 'AuthService');
        }
      }

      // 5. Token uzunluklarƒ±nƒ± kontrol et
      Logger.info('üìè Token uzunluklarƒ±:', tag: 'AuthService');
      Logger.info('üì± Local: ${localToken?.length ?? 0}', tag: 'AuthService');
      Logger.info(
        'üîî Notification: ${notificationToken?.length ?? 0}',
        tag: 'AuthService',
      );
      Logger.info(
        'üî• Firebase: ${firebaseToken?.length ?? 0}',
        tag: 'AuthService',
      );
    } catch (e) {
      Logger.error(
        '‚ùå FCM token debug hatasƒ±: $e',
        error: e,
        tag: 'AuthService',
      );
    }
  }
}
